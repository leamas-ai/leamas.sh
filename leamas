#!/bin/bash

set -euo pipefail

VERSION="0.0.1"
SCRIPT_NAME="leamas"
KITS_URL="https://leamas.sh/kits"
CACHE_DIR="$HOME/leamas/.cache"

# Color codes
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[0;37m'
BOLD='\033[1m'
DIM='\033[2m'
NC='\033[0m' # No Color

# Unicode characters
CHECK="✓"
CROSS="✗"
ARROW="→"
DOT="•"
PACKAGE="📦"
DOWNLOAD="⬇"
GLOBE="🌐"
SPARKLE="✨"
ROCKET="🚀"
WARN="⚠️"
INFO="ℹ"

print_usage() {
echo -e "
${BOLD}${CYAN}╔═══════════════════════════════════════════════════════════════╗${NC}
${BOLD}${CYAN}║${NC}                     ${BOLD}${WHITE}LEAMAS KIT INSTALLER${NC}                      ${BOLD}${CYAN}║${NC}
${BOLD}${CYAN}║${NC}               ${DIM}Install agents and commands for Claude${NC}          ${BOLD}${CYAN}║${NC}
${BOLD}${CYAN}╚═══════════════════════════════════════════════════════════════╝${NC}

${BOLD}${YELLOW}Usage:${NC} ${GREEN}$SCRIPT_NAME${NC} [${CYAN}OPTIONS${NC}] ${PURPLE}<KIT>${NC}

${BOLD}${YELLOW}Options:${NC}
    ${CYAN}-g${NC}, ${CYAN}--global${NC}       Install globally to ${DIM}~/.claude/{kit_type}/leamas/{kit_name}${NC}
    ${CYAN}-h${NC}, ${CYAN}--help${NC}         Show this help message
    ${CYAN}-l${NC}, ${CYAN}--list${NC}         List all available kits
    ${CYAN}-v${NC}, ${CYAN}--version${NC}      Show version information
    ${CYAN}-u${NC}, ${CYAN}--update${NC}       Check for and install updates

${BOLD}${YELLOW}Arguments:${NC}
    ${PURPLE}KIT${NC}                Kit format: ${DIM}{type}@{name}${NC} (e.g., ${GREEN}agent@wshobson${NC})

${BOLD}${YELLOW}Examples:${NC}
    ${DIM}$ ${NC}${GREEN}$SCRIPT_NAME${NC} ${PURPLE}agent@wshobson${NC}
    ${DIM}$ ${NC}${GREEN}$SCRIPT_NAME${NC} ${CYAN}-g${NC} ${PURPLE}agent@wshobson${NC}
    ${DIM}$ ${NC}${GREEN}$SCRIPT_NAME${NC} ${PURPLE}command@helpers${NC}
    ${DIM}$ ${NC}${GREEN}$SCRIPT_NAME${NC} ${CYAN}--list${NC}

${DIM}${BLUE}Learn more at https://leamas.sh/${NC}

"
}

print_version() {
    echo -e "${BOLD}${CYAN}$SCRIPT_NAME${NC} ${DIM}version${NC} ${GREEN}$VERSION${NC}"
}

log() {
    echo -e "${BLUE}${ARROW}${NC} $1" >&2
}

error() {
    echo -e "${RED}${CROSS} Error:${NC} $1" >&2
    exit 1
}

success() {
    echo -e "${GREEN}${CHECK}${NC} $1" >&2
}

fetch_kit_list() {
    local cache_file="$CACHE_DIR/kit_list.txt"
    
    # Create cache directory if it doesn't exist
    mkdir -p "$CACHE_DIR"
    
    # Check if cache exists and is fresh (less than 1 hour old)
    if [[ -f "$cache_file" ]] && [[ $(find "$cache_file" -mmin -60 2>/dev/null | wc -l) -gt 0 ]]; then
        cat "$cache_file"
        return 0
    fi
    
    # Fetch kit list from server
    echo -e "${CYAN}${GLOBE}${NC} Fetching available kits..." >&2
    
    # Initialize empty cache file
    > "$cache_file"
    
    # Try multiple approaches to get the kit list
    local success=false
    
    # Try to get a simple text list from the url
    if curl -sf "$KITS_URL/kit_list.txt" 2>/dev/null >> "$cache_file"; then
        success=true
    fi
    
    # Remove duplicates and empty lines
    if [[ -f "$cache_file" ]]; then
        sort "$cache_file" | uniq | grep -v '^$' > "$cache_file.tmp" && mv "$cache_file.tmp" "$cache_file"
    fi
    
    if [[ -s "$cache_file" ]]; then
        cat "$cache_file"
    else
        # If we can't fetch the list, provide a helpful message but don't fail completely
        echo "# Unable to fetch kit list from $KITS_URL" > "$cache_file"
        echo "# You can still install kits directly if you know their names" >> "$cache_file"
        echo "# Example: $SCRIPT_NAME agent@example" >> "$cache_file"
        return 1
    fi
}

list_available_kits() {
    local kits
    if kits=$(fetch_kit_list); then
        if [[ -n "$kits" ]]; then
            echo -e "\n${BOLD}${GREEN}Available Kits:${NC}"
            echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
            echo "$kits" | while IFS= read -r kit; do
                if [[ ! "$kit" =~ ^# ]]; then
                    echo -e "  ${CYAN}${DOT}${NC} ${PURPLE}$kit${NC}"
                fi
            done
            echo -e "\n${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
            echo -e "\n${DIM}${INFO} View kit details at ${BLUE}https://leamas.sh/${NC}\n"
        else
            echo -e "${YELLOW}${WARN}${NC} No kits available"
        fi
    else
        echo -e "${RED}${CROSS}${NC} Unable to fetch kit list - check your internet connection"
    fi
}

determine_target_dir() {
    local global_flag="$1"
    local kit_type="$2"
    local kit_name="$3"
    
    if [[ "$global_flag" == "true" ]]; then
        echo "$HOME/.claude/${kit_type}s/leamas/$kit_name"
    else
        echo ".claude/${kit_type}s/leamas/$kit_name"
    fi
}

create_target_dir() {
    local target_dir="$1"
    
    # Extract the .claude directory path (either .claude or ~/.claude)
    local claude_dir
    if [[ "$target_dir" =~ ^(.*/)?\.claude/ ]]; then
        claude_dir="${BASH_REMATCH[0]%.claude/*}.claude"
    else
        error "Invalid target directory: $target_dir"
    fi
    
    # Check if .claude directory exists
    if [[ ! -d "$claude_dir" ]]; then
        echo ""
        echo -e "${YELLOW}${WARN} Warning:${NC} The Claude directory '${CYAN}$claude_dir${NC}' does not exist."
        echo -e "${DIM}This may indicate that Claude is not installed or you're in the wrong directory.${NC}"
        echo ""
        echo -ne "${BOLD}Do you want to create '${CYAN}$claude_dir${NC}' and continue? ${DIM}(y/N)${NC} "
        read -n 1 -r
        echo ""
        
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo -e "\n${YELLOW}${INFO}${NC} Installation cancelled."
            echo -e "${DIM}Please ensure you're in the correct directory or Claude is installed.${NC}"
            exit 1
        fi
        
        echo -e "\n${BLUE}${ARROW}${NC} Creating Claude directory: ${CYAN}$claude_dir${NC}"
        mkdir -p "$claude_dir"
    fi
    
    # Now create the full target directory
    if [[ ! -d "$target_dir" ]]; then
        echo -e "${BLUE}${ARROW}${NC} Creating directory: ${CYAN}$target_dir${NC}"
        mkdir -p "$target_dir"
    fi
}

download_kit() {
    local kit_type="$1"
    local kit_name="$2"
    local kit_cache_dir="$CACHE_DIR/kits/${kit_type}s/$kit_name"
    
    # Create cache directory for this kit
    mkdir -p "$kit_cache_dir"
    
    # Check if kit is already cached and fresh (less than 1 day old)
    if [[ -d "$kit_cache_dir" && -n "$(find "$kit_cache_dir" -name "*.md" -mtime -1 2>/dev/null)" ]]; then
        echo "$kit_cache_dir"
        return 0
    fi
    
    echo -e "${CYAN}${DOWNLOAD}${NC}  Downloading ${BOLD}$kit_type${NC} kit: ${PURPLE}$kit_name${NC}" >&2
    
    # Clean up existing cache if it exists but is stale
    if [[ -d "$kit_cache_dir" ]]; then
        rm -rf "$kit_cache_dir"
        mkdir -p "$kit_cache_dir"
    fi
    
    # Download kit structure
    local kit_url="$KITS_URL/${kit_type}s/$kit_name"
    local download_success=false
    
    # Show progress indicator
    echo -ne "${DIM}   Fetching kit files...${NC}" >&2
    
    # Try to download a tarball or zip if available
    if curl -sf "$kit_url.tar.gz" -o "$kit_cache_dir.tar.gz" 2>/dev/null; then
        if tar -xzf "$kit_cache_dir.tar.gz" -C "$(dirname "$kit_cache_dir")" 2>/dev/null; then
            download_success=true
        fi
        rm -f "$kit_cache_dir.tar.gz"
    elif curl -sf "$kit_url.zip" -o "$kit_cache_dir.zip" 2>/dev/null; then
        if unzip -q "$kit_cache_dir.zip" -d "$(dirname "$kit_cache_dir")" 2>/dev/null; then
            download_success=true
        fi
        rm -f "$kit_cache_dir.zip"
    fi
    
    # Clear the progress line
    echo -ne "\r\033[K" >&2
    
    # Verify we downloaded something
    if [[ "$download_success" == "false" ]] || [[ -z "$(find "$kit_cache_dir" -name "*.md" -type f 2>/dev/null)" ]]; then
        # Clean up failed download
        rm -rf "$kit_cache_dir"
        error "Failed to download any files for $kit_type kit: $kit_name"
    fi
    
    echo "$kit_cache_dir"
}

parse_kit() {
    local kit="$1"
    
    if [[ ! "$kit" =~ ^([^@]+)@(.+)$ ]]; then
        error "Invalid kit format. Use: {type}@{name} (e.g., agent@wshobson, command@helpers)"
    fi
    
    local kit_type="${BASH_REMATCH[1]}"
    local kit_name="${BASH_REMATCH[2]}"
    
    # Convert singular to plural for directory names
    local kit_dir="$kit_type"
    if [[ "$kit_type" == "agent" ]]; then
        kit_dir="agents"
    elif [[ "$kit_type" == "command" ]]; then
        kit_dir="commands"
    fi
    
    # Download the kit to local cache
    local kit_path
    kit_path=$(download_kit "$kit_type" "$kit_name")
    
    if [[ ! -d "$kit_path" ]]; then
        error "Failed to download kit '$kit_name' of type '$kit_type'"
    fi
    
    # Return both path and parsed components
    echo "$kit_path|$kit_type|$kit_name"
}

is_valid_md_file() {
    local file="$1"
    local basename
    basename=$(basename "$file")
    
    # Skip README.md, LICENSE, and other non-agent files
    if [[ "$basename" == "README.md" || "$basename" == "LICENSE" || "$basename" == "CLAUDE.md" || "$basename" == "CONTRIBUTING.md" ]]; then
        return 1
    fi
    
    # Check if file starts with "---"
    if head -n 1 "$file" | grep -q "^---"; then
        return 0
    else
        return 1
    fi
}


install_kit() {
    local kit_path="$1"
    local target_dir="$2"
    local kit_type="$3"
    local kit_name="$4"
    
    echo -e "\n${PACKAGE} Installing ${BOLD}$kit_type${NC} kit: ${PURPLE}$kit_name${NC}"
    echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    local md_count=0
    
    # Simple logic based on kit type
    if [[ "$kit_type" == "agent" ]]; then
        if [[ -d "$kit_path/agents" ]]; then
            # If agents/ directory exists, use ONLY files from there
            echo -e "${DIM}   Source: agents/ directory${NC}"
            while IFS= read -r -d '' file; do
                if is_valid_md_file "$file"; then
                    local basename
                    basename=$(basename "$file")
                    cp "$file" "$target_dir/$basename"
                    ((md_count++))
                    echo -e "   ${GREEN}${CHECK}${NC} Installed: ${CYAN}$basename${NC}"
                fi
            done < <(find "$kit_path/agents" -name "*.md" -type f -print0)
        else
            # Otherwise, get .md files from root level only (not from commands/)
            echo -e "${DIM}   Source: root directory${NC}"
            while IFS= read -r -d '' file; do
                if [[ ! "$file" =~ /commands/ ]] && is_valid_md_file "$file"; then
                    local basename
                    basename=$(basename "$file")
                    cp "$file" "$target_dir/$basename"
                    ((md_count++))
                    echo -e "   ${GREEN}${CHECK}${NC} Installed: ${CYAN}$basename${NC}"
                fi
            done < <(find "$kit_path" -name "*.md" -type f -print0)
        fi
    elif [[ "$kit_type" == "command" ]]; then
        if [[ -d "$kit_path/commands" ]]; then
            # If commands/ directory exists, use ONLY files from there
            echo -e "${DIM}   Source: commands/ directory${NC}"
            while IFS= read -r -d '' file; do
                if is_valid_md_file "$file"; then
                    local basename
                    basename=$(basename "$file")
                    cp "$file" "$target_dir/$basename"
                    ((md_count++))
                    echo -e "   ${GREEN}${CHECK}${NC} Installed: ${CYAN}$basename${NC}"
                fi
            done < <(find "$kit_path/commands" -name "*.md" -type f -print0)
        else
            # Otherwise, get .md files from root level only (not from agents/)
            echo -e "${DIM}   Source: root directory${NC}"
            while IFS= read -r -d '' file; do
                if [[ ! "$file" =~ /agents/ ]] && is_valid_md_file "$file"; then
                    local basename
                    basename=$(basename "$file")
                    cp "$file" "$target_dir/$basename"
                    ((md_count++))
                    echo -e "   ${GREEN}${CHECK}${NC} Installed: ${CYAN}$basename${NC}"
                fi
            done < <(find "$kit_path" -name "*.md" -type f -print0)
        fi
    else
        error "Unknown kit type: $kit_type"
    fi
    
    echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    
    if [[ "$md_count" -eq 0 ]]; then
        error "No valid .md files found in $kit_type kit: $kit_name"
    fi
    
    echo -e "\n${GREEN}${SPARKLE}${NC} Successfully installed ${BOLD}$md_count${NC} file(s)"
}

check_for_update() {
    local github_repo="leamas-ai/leamas.sh"
    local github_branch="main"
    local remote_url="https://raw.githubusercontent.com/${github_repo}/${github_branch}/leamas"
    
    echo -e "${CYAN}${GLOBE}${NC} Checking for updates..."
    
    # Get current version
    local current_version="$VERSION"
    
    # Fetch remote version
    local remote_version
    remote_version=$(curl -sf "$remote_url" 2>/dev/null | grep '^VERSION=' | head -1 | cut -d'"' -f2)
    
    if [[ -z "$remote_version" ]]; then
        error "Failed to check for updates. Please check your internet connection."
    fi
    
    if [[ "$current_version" == "$remote_version" ]]; then
        echo -e "${GREEN}${CHECK}${NC} You're already running the latest version ${DIM}(v$current_version)${NC}"
        return 0
    else
        echo -e "${YELLOW}${INFO}${NC} Update available: ${RED}v$current_version${NC} ${ARROW} ${GREEN}v$remote_version${NC}"
        return 1
    fi
}

update_leamas() {
    local github_repo="leamas-ai/leamas.sh"
    local github_branch="main"
    local remote_url="https://raw.githubusercontent.com/${github_repo}/${github_branch}/leamas"
    local script_path="$0"
    
    # Resolve the actual script path if it's a symlink
    if [[ -L "$script_path" ]]; then
        # macOS doesn't have readlink -f, so we need a workaround
        if command -v realpath >/dev/null 2>&1; then
            script_path=$(realpath "$script_path")
        else
            # Fallback for systems without realpath
            local dir=$(dirname "$script_path")
            local base=$(basename "$script_path")
            script_path=$(cd "$dir" && pwd -P)/"$base"
        fi
    fi
    
    echo -e "\n${CYAN}${DOWNLOAD}${NC}  Updating ${BOLD}leamas${NC}..."
    
    # Download new version to temp file
    local temp_file
    temp_file=$(mktemp)
    
    # Show progress
    echo -ne "${DIM}   Downloading latest version...${NC}"
    
    if ! curl -sSL -o "$temp_file" "$remote_url"; then
        echo -ne "\r\033[K"
        rm -f "$temp_file"
        error "Failed to download update"
    fi
    
    echo -ne "\r\033[K"
    
    # Verify the download contains valid script
    if ! grep -q '^VERSION=' "$temp_file"; then
        rm -f "$temp_file"
        error "Downloaded file does not appear to be a valid leamas script"
    fi
    
    # Backup current version
    cp "$script_path" "${script_path}.bak"
    
    # Replace with new version
    if cp "$temp_file" "$script_path" && chmod +x "$script_path"; then
        rm -f "$temp_file"
        rm -f "${script_path}.bak"  # Clean up backup on success
        local new_version
        new_version=$(grep '^VERSION=' "$script_path" | head -1 | cut -d'"' -f2)
        echo -e "${GREEN}${SPARKLE}${NC} Successfully updated to version ${GREEN}v$new_version${NC}"
        echo -e "\n${DIM}Run ${GREEN}leamas --version${NC} ${DIM}to verify the update${NC}"
    else
        # Restore backup on failure
        mv "${script_path}.bak" "$script_path"
        rm -f "$temp_file"
        error "Failed to update leamas"
    fi
}

main() {
    local global_flag="false"
    local kit=""
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -g|--global)
                global_flag="true"
                shift
                ;;
            -h|--help)
                print_usage
                exit 0
                ;;
            -v|--version)
                print_version
                exit 0
                ;;
            -l|--list)
                list_available_kits
                exit 0
                ;;
            -u|--update)
                if check_for_update; then
                    exit 0
                else
                    echo -ne "\n${BOLD}Do you want to update now? ${DIM}(y/N)${NC} "
                    read -n 1 -r
                    echo
                    if [[ $REPLY =~ ^[Yy]$ ]]; then
                        update_leamas
                    else
                        echo -e "\n${YELLOW}${INFO}${NC} Update cancelled"
                    fi
                    exit 0
                fi
                ;;
            -*)
                error "Unknown option: $1"
                ;;
            *)
                if [[ -n "$kit" ]]; then
                    error "Multiple kits provided. Please specify only one."
                fi
                kit="$1"
                shift
                ;;
        esac
    done
    
    if [[ -z "$kit" ]]; then
        error "Kit is required. Use -h for help."
    fi
    
    # Parse kit and extract components
    local kit_info
    kit_info=$(parse_kit "$kit")
    
    local kit_path kit_type kit_name
    IFS='|' read -r kit_path kit_type kit_name <<< "$kit_info"
    
    local target_dir
    target_dir=$(determine_target_dir "$global_flag" "$kit_type" "$kit_name")
    
    create_target_dir "$target_dir"
    
    install_kit "$kit_path" "$target_dir" "$kit_type" "$kit_name"
    
    echo -e "\n${ROCKET} ${BOLD}Installation complete!${NC}"
    echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}"
    echo -e "${INFO} ${BOLD}$kit_type${NC} kit is available in:"
    echo -e "   ${CYAN}$target_dir${NC}"
    echo -e "${DIM}━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━${NC}\n"
}

main "$@"